import { promises as fs } from 'node:fs'
import type { BaseCallExpression, Expression, SpreadElement } from 'estree'
import { parse } from 'acorn'
import { useLogger } from '@nuxt/kit'
import { falsy } from '../helpers'
import type {
  Extraction,
  ExtractionPlural,
  ExtractionText,
} from '../moduleTypes'
import { extractMethodCalls } from '../vitePlugin'

/**
 * Service to handle text extractions across multiple files.
 */
export default class Extractor {
  files: Record<string, Record<string, Extraction>> = {}
  isBuild = false

  constructor(isBuild = false, globalTexts?: Record<string, string>) {
    this.isBuild = isBuild
    this.files['nuxt.config.ts'] = {}

    if (globalTexts) {
      Object.entries(globalTexts).forEach(([fullKey, defaultText]) => {
        const { key, context } = parseKey(fullKey)
        this.files['nuxt.config.ts']![fullKey] = {
          type: 'text',
          fullKey,
          key,
          context,
          defaultText,
          filePath: 'nuxt.config.ts',
        }
      })
    }
  }

  /**
   * Add files by path.
   */
  addFiles(files: string[]): Promise<boolean[]> {
    return Promise.all(files.map((v) => this.handleFile(v)))
  }

  /**
   * Read the file and extract the texts.
   *
   * Returns a promise containing a boolean that indicated if the given file
   * should trigger a rebuild of the query.
   */
  async handleFile(filePath: string): Promise<boolean> {
    const source = await this.readFile(filePath)
    const extractions = this.getExtractions(source, filePath)

    // New file that didn't previously contain text extractions.
    if (!this.files[filePath]) {
      this.files[filePath] = {}
      extractions.forEach((v) => {
        this.files[filePath]![v.fullKey] = v
      })
      return true
    }

    const differentLength =
      Object.keys(this.files[filePath]).length !== extractions.length

    // File previously contained extractions. Compare the two arrays to
    // determine if something changed.
    const hasChange =
      differentLength ||
      extractions.some((extraction) => {
        const existing = this.files[filePath]![extraction.fullKey]
        // New extraction key.
        if (!existing) {
          return true
        }
        if (existing.type !== extraction.type) {
          return true
        }

        if (existing.type === 'text' && extraction.type === 'text') {
          if (existing.defaultText !== extraction.defaultText) {
            return true
          }
        }

        if (existing.type === 'plural' && extraction.type === 'plural') {
          if (existing.singular !== extraction.singular) {
            return true
          }
          if (existing.plural !== extraction.plural) {
            return true
          }
        }

        return false
      })

    if (hasChange) {
      this.files[filePath] = {}
      extractions.forEach((v) => {
        this.files[filePath][v.fullKey] = v
      })
    }

    return hasChange
  }

  handleError(filePath: string, code: string, e: any) {
    const message =
      typeof e === 'object' && e !== null
        ? e.message
        : 'Failed to parse text arguments.'

    logger.error(`${message + filePath}\n`, code)

    if (this.isBuild) {
      throw new Error('Failed to extract texts.')
    }
  }

  /**
   * Read the given file and return its contents.
   */
  readFile(filePath: string) {
    return fs.readFile(filePath).then((v) => {
      return v.toString()
    })
  }

  /**
   * Generate the query.
   */
  getUniqueExtractions(): Extraction[] {
    const allExtractions: Extraction[] = Object.keys(this.files)
      .map((file) => {
        const extractionMap = this.files[file] || {}
        return Object.keys(extractionMap).map((v) => extractionMap[v])
      })
      .flat()
      .filter(falsy)

    // Create map for the unique text keys.
    const texts: Record<string, Extraction> = allExtractions.reduce<
      Record<string, Extraction>
    >((acc, v) => {
      const existing = acc[v.fullKey]
      if (existing) {
        if (
          'defaultText' in existing &&
          'defaultText' in v &&
          existing.defaultText !== v.defaultText &&
          existing.defaultText &&
          v.defaultText
        ) {
          logger.info(
            `The text key "${v.fullKey}" has multiple different default texts:"`,
          )
          logger.info(v.filePath)
          logger.info(v.defaultText)
          logger.info(existing.filePath)
          logger.info(existing.defaultText)
        } else if (existing.type !== v.type) {
          logger.info(
            `The text key "${v.fullKey}" is used for two different text types:"`,
          )
          logger.info(v.filePath)
          logger.info(existing.filePath)
        }
      }

      // Only set it once.
      if (!existing) {
        acc[v.fullKey] = v
      }

      return acc
    }, {})

    return Object.values(texts).sort((a, b) =>
      a.fullKey.localeCompare(b.fullKey),
    )
  }
}
